#summary Getting started
#labels Featured

= What are class loader leaks? =

In a J2EE environment, the container will create a separate class loader for each application. More precisely, in a full featured J2EE application server, there will be a separate class loader for each enterprise application (EAR), and each Web application (WAR) will also get its own class loader, which will be a child of the EAR class loader. Obviously, pure Servlet containers such as Tomcat which don't support EAR deployment will only create class loaders for WAR files.

Whenever an application is restarted or redeployed, the container will create a new class loader for the new application instance. It relies on the garbage collector to free the class loader of the stopped application instance. If for some reason after stopping an application a component outside of the application (i.e. in the JRE or in the server runtime) still holds a strong reference to the class loader of the stopped application instance, then the garbage collector will not remove the class loader from memory. This causes a particular type of memory leak called _class loader leak_.

In an environment where applications are frequently restarted or redeployed without restarting the entire server, a class loader leak will eventually result in an out of memory error (although it may require many application restarts before this actually occurs). With an Oracle JRE, the error message one gets in this case is typically `java.lang.OutOfMemoryError: PermGen space`. That is because class files are stored in the !PermGen space and this is typically the memory area that gets filled first (A class file can only be discarded from memory when the corresponding class loader is garbage collected). The error will be different on other JRE implementations because memory is organized differently, but the end result is the same.

= Costs and risks related to class loader leaks =

Addressing class loader leaks is challenging and costly:
  * They may go unnoticed for a long time. As noted above, depending on the application and on the container configuration (heap sizes), it is possible that a class loader leak triggers an out of memory error only after a very large number of application restarts. Since a change introducing a class loader leak will not result in an error immediately, it is not easy to identify which change caused the leak.
  * It is not easy to test an application for class loader leaks. One may attempt to do this by repeatedly restarting the application and observing the impact on memory utilization, or by checking if after stopping an application, the number of loaded classes in the JVM decreases. However, most real world applications have components that are only initialized lazily. This means that some class loader leaks will be triggered only after the application has processes a particular kind of request, which makes these approaches ineffective.
  * In general, identifying the root cause of a class loader leak requires to take a heap dump of the JVM and analyzing it with an appropriate tool such as [http://www.eclipse.org/mat/ Eclipse Memory Analyzer]. This is not only tedious but also requires a great deal of experience (especially when analyzing large dumps from acceptance or production systems).

Some people have argued that because eliminating class loader leaks is costly (and many class loader leaks only have a marginal impact), one should not bother about them and simply make sure that there is enough margin in memory allocation and to regularly restart the entire application server (or even require a restart of the application server every time an application is redeployed, at least on production systems).

Obviously this is a reasonable argument (at least in a business environment where decisions are based on economic arguments), but there are several things that should be taken into account before deciding to follow a strategy based on this argument:
  * It is based on the assumption that it is costly to identify and eliminate class loader leaks. As explained in the next section, the Arit project attempts to change this and reduce these costs by providing a tool to identify the most common types of class loader leaks.
  * Accepting applications with class loader leaks means accepting the latent risk of encountering an out of memory condition because the application server was not restarted in time and/or accepting the additional risk and cost caused by frequent application server restarts.
  * A class loader leak may be coupled to another issue that may represent a larger threat to the stability or operability of the environment than the leak itself. Keeping an eye on class loader leaks may therefore also help eliminating other, more important issues. Here are a couple of examples to illustrate this, including real world incidents:
    * In one case, an application exposing a custom MBean failed to unregister that MBean when stopping the application, causing a class loader leak. In addition to that, the application silently skipped registration of the MBean if the MBean already existed. The net result was that after an application restart, the registered custom MBean wouldn't allow to manage the currently running application instance, but a previously stopped one.
    * The documentation of the [JULHandler JUL plugin] describes an incident where an application unexpectedly registered an instance of `SLF4JBridgeHandler` into the JRE, not only causing a class loader leak, but also making the environment vulnerable to a deadlock which took down the server within minutes after its occurrence.
    * In some cases, the class loader leak is the a side effect of another more important memory leak that would eventually cause an out of memory error even without application restarts. This occurs if the application creates more and more strong references to distinct object instances (i.e. has a classic memory leak) and these references happen to be held directly or indirectly by something outside of the application (which then creates a class loader leak).
  * Not taking care of class loader leaks makes it harder to address classic memory leaks (which usually can't be simply ignored):
    * It is notoriously difficult to assess the memory footprint of a J2EE application. One way to get a reasonable estimate is to stop the application and observe the impact on heap usage. However, if the application also has a class loader leak, then this method is no longer effective.
    * Analyzing a classic memory leak becomes virtually impossible to do if the heap dump not only contains objects from the currently running instance of an application, but also from stopped ones (which occurs if the application has a class loader leak).

= How does Arit help with class loader leaks? =

The aim of the Arit project is to provide a tool that helps reducing the risks and costs caused by class loader leaks. It does so in two ways:
  * Arit reduces costs by identifying common types of class loader leaks without the need to take a heap dump of the Java process. Instead, Arit is deployed as a simple Web application and is able to generate an online report of the detected leaks (or leak suspects). In most cases, the information provided by the report makes it easy to identify the code causing the class loader leak, so that the issue can be fixed in a cost efficient way.
  * Arit reduces risks by providing an estimation of the number of leaked class loader instances (Obviously, since Arit is not able to identify each and every class loader leak, this metric only provides a lower bound). Monitoring this metric helps determining when it is time to preventively restart the application server.

= How does Arit work? =

As explained above, a class loader leak occurs if something outside of the application keeps a strong reference to an instance of a class loaded from the application class loader (or in some cases to the class loader itself) and if that reference is not removed when the application is stopped. With the exception of bugs in the JRE or the application server, this type of reference is always created by some explicit action requested by the application. An example is a custom MBean registered by the application. This will create a strong reference from the MBean server in the JRE or the application server to the MBean implementation loaded by the application. If the application doesn't unregister the MBean, then this strong reference prevents the application class loader from being garbage collected.

Obviously there will not be an infinite number of places (outside of the application) where such a strong reference can be held. This will always involve some kind of registry (such as the MBean server in the example cited above) exposed by the JRE or the container and into which the application registers one of its objects. The idea behind the Arit project is to identify these places (or at least the ones that are most commonly associated with class loader leaks) and to provide a tool that inspects the relevant data structures to search for references that point to application instances.

In some cases these data structures can be inspected using public APIs. E.g. searching the `java.util.logging` subsystem for handlers registered by applications can easily be done using the APIs defined by `LogManager` and `Logger`. In other cases this is not possible. E.g. JMX defines methods to identify all MBean registered in a particular MBean server, but (by design) there is no way to get the reference to the actual MBean implementation using the available public APIs. In these cases Arit relies on reflection to access the private members of the relevant data structures. Obviously this makes Arit implementation dependent. This is unavoidable and explains why Arit only supports certain JREs and servers (see next section). However, Arit has a flexible plugin architecture that makes it easy to support different implementations (such as JREs from different vendors).

As mentioned above, there is another category of class loader leaks that is caused by bugs in the JRE or the application server. In this case, it is the runtime environment itself that creates strong references to an application class loader. Although this typically occurs as a side effect of an action executed by the application, the application (or the application developer) can't be blamed for this. Arit handles these type of leaks in the same way, by examining the relevant data structures. However, this obviously introduces an even higher level of product dependence. An example is the [http://www-01.ibm.com/support/docview.wss?uid=swg1IZ67457 IZ67457] bug affecting some versions of the IBM JDK. Occurrences of this bug can easily be detected using reflection, but this obviously only covers one particular bug occurring in products from one particular vendor.

To generate a meaningful report based on the collected information, Arit also needs to identify to which application a given class loader belongs and whether the corresponding application instance is still running or has already been stopped. This also requires server specific code and is currently only supported for a handful of servers.

After all this theory, let's see what kind of report Arit actually produces from the collected information. The following screenshot shows an example:

http://arit.googlecode.com/svn/wiki/screenshot1.png

This was taken on a Tomcat which had Axis2 1.5.2 deployed. The report provides evidence for the issue described in [https://issues.apache.org/jira/browse/AXIS2-4263 AXIS2-4263]: Axis2 starts two timers, but fails to cancel one when the application is stopped. Indeed, the upper part of the screenshot shows a running instance of Axis2 with the two timers, while the other part shows a stopped instance with the remaining timer identified by Arit. Note that the "JULI per class loader logging context" actually represents a weak reference to the class loader which would eventually disappear if all other strong references were cleared.

= Relation to Tomcat's memory leak prevention and detection feature =

Arit is actually based on an idea borrowed from Tomcat. In 2010, the Tomcat developers added a memory leak prevention and detection feature, which is explained in more detail [http://www.tomcatexpert.com/blog/2010/04/06/tomcats-new-memory-leak-prevention-and-detection here]. The techniques used are similar, but Arit expands on them and there are some significant differences:
  * The feature in Tomcat focuses on a small set of very common leaks and the aim is to perform automatic cleanup as a workaround for these leaks. On the other hand, Arit is focused on detection and reporting of a broader set of class loader leaks, while cleanup of these leaks is not a (primary) goal.
  * Arit runs in other application servers as well.